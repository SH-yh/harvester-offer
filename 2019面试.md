
# http相关  

1.https与http区别

```$javascript

http是基于tcp协议的，https是基于ssl协议的，ssl协议在tcp协议的基础上的做了一层加密认证。
https比http传输数据更安全，http是明文传递数据，不安全；而https传输数据经过加密。
https需要证书来验证身份，证书需要购买，http不需要。
https默认端口号是443，http默认是80。
https不能向http发出请求。

了解https通讯过程：

（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

（5）Web服务器利用自己的私钥解密出会话密钥。

（6）Web服务器利用会话密钥加密与客户端之间的通信

```

2.http请求过程及拿到响应后的渲染过程？
 
```$javascript

http请求过程：
1.浏览器检查当前请求的url是否存在强缓存？命中强缓存，则缓存中读取。
2.dns解析：
  a.浏览器缓存的dns解析，是否存在。
  b.操作系统DNS缓存中搜索
  c.本地host进行dns解析。
  d.向dns服务器发起请求进行dns解析
3.建立tcp链接，三次握手。
4.浏览器发出http请求
5.服务器分析路由，处理请求，返回响应。
6.浏览器接受响应，渲染页面，构建dom
7。关闭tcp链接（4次挥手）  

渲染过程：
1.解析html文件，浏览器按照文档流顺序，构建dom树。（深度遍历，当所有子节点都构建好后，才会去构建当前节点的下一个兄弟节点）
2.浏览器解析css形成css规则树。
3.根据dom树和css规则树，构造出渲染树。
   渲染树：浏览器可以知道网页中有那些节点，各个节点的css以及他们从属关系
   
4.遍历渲染树，计算每个节点位置大小信息，然后进行绘制。

扩展：重绘 和 回流
重绘：dom的一部分进行重画，不影响整体布局。
触发：css背景色...
回流：重新计算渲染树，重新遍历渲染树，重新渲染，浪费性能；
触发：宽高、字体、resize等。
优化：利用文档碎片document.createDocumentFragment并不是真正的dom，操作dom；


```
3.http缓存机制。

[点击查看详细浏览器缓存技术，面试难不倒](https://juejin.im/post/5b9346dcf265da0aac6fbe57)
```$javascript
强缓存： 
    响应报文头：
    catch-control：max-age=212121； 最长生效时常。
    expires:服务器绝对时间
    
    客户端发请求前，会用当前客户端时间与 （上次请求时间+max-age）进行比较，命中则走缓存。
    expires是一个绝对时间，采用的是服务器的。客户端发送请求前，用客户端时间与这个时间进行比较，命中则走缓存。
    max-age优先级比expires高，并且更加靠谱；
    
弱缓存（协商缓存）:
    响应报文头:
    last-modified：最后一次修改时间
    Etag：当前请求的资源生成的一个唯一标识，只要资源不一样这个串就不一样
    
    请求报文头：
    if-modified-since:缓存中文件的最后修改时间
    if-None-Match:缓存中文件的etag
    
    
    客户端发出请求，携带if-modified-since，if-None-Match字段，服务器收到请求 与当前文件的最后修改时间和
    重新生成etag进行比较，命中则返回304； 
    如果命中if-none-match，返回304的响应头中，会携带服务器最新生成的etag;
    如果命中if-modified-since则304响应头中不会携带last-modified，因为最后修改时间没有改变。
    
    注意：etag优先级比 last-modified要高。但是各有优缺点；
        分布式系统里多台机器文件的last-modified必须保持一致，要不负载均衡到不同机器导致对比失败。
        分布式系统计量关闭掉etag，因为每台服务器生成的etag都不一样。
   
    
    使用：协商缓存需要配合强缓存使用，
   
```
4.http get和post区别？

5.http状态码

6.列举你所知道的请求头中的字段和响应头中的字段

# js基础相关

1.js继承？原型链查找原理。

[查看原型链查找和继承](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/12.%E5%8E%9F%E5%9E%8B%E9%93%BE/12.%E5%8E%9F%E5%9E%8B%E9%93%BE.js)


2.es6 class继承如何实现？

[剖析class继承过程](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/14.es6/11.class-extends.js)

3.var let const 区别

[查看var，let，const区别](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/14.es6/1.let%26const.js)

4.promise的特点，使用及原理。

5.generator函数的使用及原理

6.es6 解构赋值和数组的操作方法

[es6各种解构赋值使用](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/14.es6/2.%E8%A7%A3%E6%9E%84.js)

[es6数组方法的实现过程和调用](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/14.es6/7.Array.js)

7.讲一下js循环事件池event loop，微任务和宏任务

8.js的垃圾处理机制

9.localstorage、sessionStorage 、cookie区别？（水滴）

[查看区别](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/2.bom/2.bom.js)

10.什么是闭包，说下项目中应用场景？（水滴）
```$javascript
   函数执行会开辟一个新的作用域，这个作用域内声明的变量不能被外部函数，但是可以被子函数所访问，这就可以认为是闭包。
   存在闭包的作用域 是得不到的释放的。
   一个闭包就是当一个函数返回时，一个没有释放资源的栈区。
   
   场景：
   1.可以实现公有变量，函数外或在其他函数中访问某一函数内部的参数
    function add() {
             var num = 0;
             function demo(){
                num++;
                console.log(num);
                }
                return demo;
           }
    var test = add();
    test();//1
    test();//2
   
  2.为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点
  
  3.计数器
    function checkCount(fn){
        let count = 0;
        let target = 3;
        return function(){
              count++;
              if(count == target){
                fn();
              }
        }
    }
    
    4.函数节流和防抖
    
```


11.ajax工作原理？

```$javascript


var xhr = new XMLHttpRequest();
xhr.open('GET','/api',true);//true表示异步
xhr.onreadystatechange = function() {
  if(xhr.readyState == 4 && xhr.status == 200){
      console.log(xhr.responseText)
  }
}
xhr.send();


步骤：1.创建xhr请求对象
     2.创建http请求
     3.监听状态变化
     4.根据状态码处理结果,
            ⑴未初始化状态。在创建完XMLHttpRequest对象时，该对象处于未初始化状态，此时XMLHttpRequest对象的readyState属性值为0。
     
            ⑵初始化状态。在创建完XMLHttpRequest对象后使用open()方法创建了HTTP请求时，该对象处于初始化状态。此时XMLHttpRequest对象的readyState属性值为1。
     
            ⑶发送数据状态。在初始化XMLHttpRequest对象后，使用send()方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest对象的readyState属性值为2。
     
            ⑷接收数据状态。Web服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest对象处于接收数据状态，XMLHttpRequest对象的readyState属性值为3。
     
            ⑸完成状态。XMLHttpRequest对象接收数据完毕后，进入完成状态，此时XMLHttpRequest对象的readyState属性值为4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用responseText属性或responseXml属性来获取数据。
     
      只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态
     5.发送请求


```

12.js事件代理？

13.js中this是如何工作的

[this指向规则](https://github.com/qiaoshi123/harvester-offer/tree/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/13.this)

14.怎么判断引用数据类型？（为什么能用Object.prototype.toString.call()去判断？）
   
```$javascript
1.instanceof 判断不准确
var a = [];
a instanceof Array  true
a instanceof Object  true 

2.Object.prototype.toString.call([])  '[object Array]'
  Object.prototype.toString.call({})   "[object Object]"
  
  
3.isPrototypeiOf
Array.prototype.isPrototypeOf([])

4.[].constructor == Array.prototype.constructor



扩展：
Array.toString == Function.prototype.toString  true，
根据原型链查找，查到Function.prototype.toString就停了。不会查到Object.prototype

[].toString == Array.prototype.toString  true.
根据原型链查找，查到Array.prototype.toString就停了。不会查到Object.prototype

Array,Function 都在各自的原型上重新定义了toString方法，阻断了查找。

```


15.js变量提升和作用域查找？

[作用域查找](https://github.com/qiaoshi123/harvester-offer/tree/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/11.%E4%BD%9C%E7%94%A8%E5%9F%9F)
```$javascript
console.log(type a) //undefined  变量提升
console.log(type b) //err:b is not defined ,后续代码不执行
console.log(type c) 
var a = function(){return true}; //变量提升
window.b = function(){  //给window创建属性，不存在变量提升
	return true;
}
console.log(a() && b() && c())
function c(){return c}


var o = {
	a:1,
	f(){
		return this.a;
	}
}
console.log(o.f()); //1
var o1 = o;
console.log(o1.f());//1
var o2 = o.f;
console.log(o2()); //undefined  =>this是window，window.a undefined;
o.a=  5;
console.log(o1.f());//5  堆内存 和 栈内存
var o3 = {a:5}; 
console.log(o.f.call(o3)) //5 
```

16.call apply bind 区别？如何实现？

[查看手写call，apply，bind](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/5.function/5.function.js)

17.实现跨域的方法？说一下JSOP的原理？



# HTML+CSS相关

1.meta标签常用有哪些，列举？viewport属性有哪些分别代表什么（水滴）

2.清除浮动方法？（水滴）

3.口述css盒子模型（水滴）

4.实现左右固定宽度中间自适应布局有哪几种？（水滴）

5.position属性有哪几种，区别？（水滴）

6.左侧固定宽度，右侧自适应？

# 前端框架相关

1.什么是mvvm？mvvm实现原理？

[手写mvvm框架](https://github.com/qiaoshi123/harvester-offer/tree/master/%E6%A1%86%E6%9E%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/2.mvvm%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF)
```
双向数据绑定
M 数据层
V 视图层
VM View-Modle层，主要用于数据和视图的通讯

利用Object.definedProperty 对data属性的get 和set 进行拦截和监听，并对每个data属性创建一个订阅池。
在编译dom阶段，对dom进行解析，"v-**" "{{}}"，每编译到一处， 完成首次渲染，而且注册一个监听者，添加到data属性的订阅池中。
数据影响视图：当数据改变，则通知该属性对应订阅池中所有的watcher，进行更新。
视图影响数据(v-model): 通过绑定事件，然后改变data属性值，data属性值发生改变，通知所有watcher更新视图。

设计思想：发布订阅+观察者模式，es6 definedProperty拦截。

```

2.vue兄弟组件传递数据？
```$javascript
父传子：通过给子组件绑定属性传值，:data=""。子组件接收通过props设置接收的属性。
子传父：通过事件传值，给子组件绑定事件，@事件名="父组件方法",子组件改变了数据，
通过this.$emit(事件名,data)通知父组件。

兄弟组件传值:中间件
1.
创建一个单独的vm实例。
通过vm.$on('事件名',方法)绑定事件
通过vm.$emit(事件名，data)通知兄弟组件修改数据。
2.合并到同一个父组件下，通过父组件进行传值。
3.vuex

```
3.vuex的使用场景？如何使用？原理？

4.用vue-router实现导航切换 类似tab栏的那种

5.vue和react区别 

6.vue 的watch中可以使用箭头函数吗
```$javascript
    不能使用,箭头函数在声明时就确定了this指向，指向的是父级作用域上下文。
    当函数执行时，里面的this并不是vue实例。

```
# 前端工程化相关
1.webpack基本配置有哪些？

2.vue-cli3脚手架的基本配置？

3.webpack作用？

```
1、合并js文件，压缩代码；处理图片资源等静态资源，减少http请求；
2、css预处理，编译less/sass等浏览器不能直接识别的语言；
3、对文件进行hash，可以防止浏览器缓存。
4、一切皆模块，让模块更容易服用，避免重复加载或者加载不必要的模块，并且能够防止全局变量冲突。
```

# 应用场景开发相关

1.简述微信公众号授权过程？

#场景题
1.将aabbcccd 字符传替换成abcd？（水滴）
```$javascript
利用数组去重,这种不会有重复项，aabbcccdc=>字符传替换成abcd
function  switchStr(str) {
    return Array.from(new Set(str.split(""))).join("")
}

reduce拼接，这种会有重复项，aabbcccdc=>字符传替换成abcdc
function switchStr(str) {
    let arr = str.split('');
    return arr.reduce((prev,next,index,origin)=>{
        if(prev.slice(prev.length-1) == next){
            return prev;
        }else{
            return prev + next;
        }


    },'')
}
```

2.js实现字符串trim方法
```$javascript
原生：
var a = '  123  '
a.trim();

js实现：
String.prototype.trim = function(){
    return this.replace(/(^\s+|\s+$)/g,function(){
       return ""
    })
}

```

2.原生js实现字符串split方法？

```javascript


```


3.函数节流？防抖？有何区别？

[防抖,节流](https://juejin.im/post/5c87b54ce51d455f7943dddb)

```javascript
// 函数节流
function throttle(fn,delay) {
    let flag = true;
    return function() {
        if(!flag){
            return;
        }
        flag = false;
        setTimeout(()=>{
            fn.call(this,arguments);
            flag = true;
        },delay)
    }
}

//防抖

function debounce(fn) {
  let timer = null;
  return function() {
    clearTimeout(timer);
    timer = setTimeout(()=>{
        fn.call(this,arguments)
    },1000)
  }
  
  //区分： 节流在一定时间内调用多次，总是执行第一次调用的，执行完成后，才能再次调用。
  //      防抖在一定时间内调用多次，后续的调用会覆盖前面的调用，执行的永远是最后一次调用的。
    
   
}





```



4.[a,b,c],写个方法将数组全排列 ，变成[abc,acb,bac,bca,cab,cba]
```$javascript
    

```
5.数组对象去重
```$javascript

```

6.你所用到的排序方法

[冒泡、选择、快排、插入排序](https://github.com/qiaoshi123/harvester-offer/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.js)

7.实现一个方法，能够把多重数组变成一个一维数组,flat方法。[1,[1,2],[3,4,5]]转换为[1,1,2,3,4,5]
```javascript




```

# 性能优化相关？

1.列举你能想到的前端性能问题和安全问题

# 扩展知识？能聊就行～

1.简述CI/CD？

2.多态和重载？

3.了解服务端的反向代理吗？







