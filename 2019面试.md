
# http相关  

1.https与http区别

```$javascript

http是基于tcp协议的，https是基于ssl协议的，ssl协议在tcp协议的基础上的做了一层加密认证。
https比http传输数据更安全，http是明文传递数据，不安全；而https传输数据经过加密。
https需要证书来验证身份，证书需要购买，http不需要。
https默认端口号是443，http默认是80。
https不能向http发出请求。

了解https通讯过程：

（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。

（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

（5）Web服务器利用自己的私钥解密出会话密钥。

（6）Web服务器利用会话密钥加密与客户端之间的通信

```

2.http请求过程及拿到响应后的渲染过程？
 
```$javascript

http请求过程：
1.浏览器检查当前请求的url是否存在强缓存？命中强缓存，则缓存中读取。
2.dns解析：
  a.浏览器缓存的dns解析，是否存在。
  b.操作系统DNS缓存中搜索
  c.本地host进行dns解析。
  d.向dns服务器发起请求进行dns解析
3.建立tcp链接，三次握手。
4.浏览器发出http请求
5.服务器分析路由，处理请求，返回响应。
6.浏览器接受响应，渲染页面，构建dom
7。关闭tcp链接（4次挥手）  

渲染过程：
1.解析html文件，浏览器按照文档流顺序，构建dom树。（深度遍历，当所有子节点都构建好后，才会去构建当前节点的下一个兄弟节点）
2.浏览器解析css形成css规则树。
3.根据dom树和css规则树，构造出渲染树。
   渲染树：浏览器可以知道网页中有那些节点，各个节点的css以及他们从属关系
   
4.遍历渲染树，计算每个节点位置大小信息，然后进行绘制。

扩展：重绘 和 回流
重绘：dom的一部分进行重画，不影响整体布局。
触发：css背景色...
回流：重新计算渲染树，重新遍历渲染树，重新渲染，浪费性能；
触发：宽高、字体、resize等。
优化：利用文档碎片document.createDocumentFragment并不是真正的dom，操作dom；


```
3.http缓存机制。

[点击查看详细浏览器缓存技术，面试难不倒](https://juejin.im/post/5b9346dcf265da0aac6fbe57)
```$javascript
强缓存： 
    响应报文头：
    catch-control：max-age=212121； 最长生效时常。
    expires:服务器绝对时间
    
    客户端发请求前，会用当前客户端时间与 （上次请求时间+max-age）进行比较，命中则走缓存。
    expires是一个绝对时间，采用的是服务器的。客户端发送请求前，用客户端时间与这个时间进行比较，命中则走缓存。
    max-age优先级比expires高，并且更加靠谱；
    
弱缓存（协商缓存）:
    响应报文头:
    last-modified：最后一次修改时间
    Etag：当前请求的资源生成的一个唯一标识，只要资源不一样这个串就不一样
    
    请求报文头：
    if-modified-since:缓存中文件的最后修改时间
    if-None-Match:缓存中文件的etag
    
    
    客户端发出请求，携带if-modified-since，if-None-Match字段，服务器收到请求 与当前文件的最后修改时间和
    重新生成etag进行比较，命中则返回304； 
    如果命中if-none-match，返回304的响应头中，会携带服务器最新生成的etag;
    如果命中if-modified-since则304响应头中不会携带last-modified，因为最后修改时间没有改变。
    
    注意：etag优先级比 last-modified要高。但是各有优缺点；
        分布式系统里多台机器文件的last-modified必须保持一致，要不负载均衡到不同机器导致对比失败。
        分布式系统计量关闭掉etag，因为每台服务器生成的etag都不一样。
   
    
    使用：协商缓存需要配合强缓存使用，
   
```
4.http get和post区别？

```$javascript

GET在浏览器回退时是无害的，而POST会再次提交请求。

GET产生的URL地址可以被Bookmark，而POST不可以。

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求只能进行url编码，而POST支持多种编码方式。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET请求在URL中传送的参数是有长度限制的，而POST么有。
get传送的数据量较小，不能大于2KB。post传送的数据量较大

对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 

GET参数通过URL传递，POST放在Request body中。

GET产生一个TCP数据包；POST产生两个TCP数据包
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

```


5.http状态码

6.列举你所知道的请求头中的字段和响应头中的字段

7.复杂请求的与简单请求的区别 

8.http2 和http1.1的区别




# js基础相关

1.js继承？原型链查找原理。

[查看原型链查找和继承](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/12.%E5%8E%9F%E5%9E%8B%E9%93%BE/12.%E5%8E%9F%E5%9E%8B%E9%93%BE.js)
```$javascript
function inheritPrototype(subType, superType){ 
    // 继承父类的原型
    var prototype = Object.create(superType.prototype);
    // 重写被污染的construct
    prototype.constructor = subType; 
    // 重写子类的原型  
    subType.prototype = Object.assign(prototype, subType.prototype); 
}

```



2.es6 class继承如何实现？

[剖析class继承过程](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/14.es6/11.class-extends.js)

3.var let const 区别

[查看var，let，const区别](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/14.es6/1.let%26const.js)

4.promise的特点，使用及原理。

5.generator函数的使用及原理

6.es6 解构赋值和数组的操作方法

[es6各种解构赋值使用](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/14.es6/2.%E8%A7%A3%E6%9E%84.js)

[es6数组方法的实现过程和调用](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/14.es6/7.Array.js)

7.讲一下js循环事件池event loop，微任务和宏任务

8.js的垃圾处理机制

9.localstorage、sessionStorage 、cookie区别？（水滴）

[查看区别](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/2.bom/2.bom.js)

10.什么是闭包，说下项目中应用场景？（水滴）
```$javascript
   函数执行会开辟一个新的作用域，这个作用域内声明的变量不能被外部函数，但是可以被子函数所访问，这就可以认为是闭包。
   存在闭包的作用域 是得不到的释放的。
   一个闭包就是当一个函数返回时，一个没有释放资源的栈区。
   
   场景：
   1.可以实现公有变量，函数外或在其他函数中访问某一函数内部的参数
    function add() {
             var num = 0;
             function demo(){
                num++;
                console.log(num);
                }
                return demo;
           }
    var test = add();
    test();//1
    test();//2
   
  2.为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点
  
  3.计数器
    function checkCount(fn){
        let count = 0;
        let target = 3;
        return function(){
              count++;
              if(count == target){
                fn();
              }
        }
    }
    
    4.函数节流和防抖
    
```


11.ajax工作原理？

```$javascript


var xhr = new XMLHttpRequest();
xhr.open('GET','/api',true);//true表示异步
xhr.onreadystatechange = function() {
  if(xhr.readyState == 4 && xhr.status == 200){
      console.log(xhr.responseText)
  }
}
xhr.send();


步骤：1.创建xhr请求对象
     2.创建http请求
     3.监听状态变化
     4.根据状态码处理结果,
            ⑴未初始化状态。在创建完XMLHttpRequest对象时，该对象处于未初始化状态，此时XMLHttpRequest对象的readyState属性值为0。
     
            ⑵初始化状态。在创建完XMLHttpRequest对象后使用open()方法创建了HTTP请求时，该对象处于初始化状态。此时XMLHttpRequest对象的readyState属性值为1。
     
            ⑶发送数据状态。在初始化XMLHttpRequest对象后，使用send()方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest对象的readyState属性值为2。
     
            ⑷接收数据状态。Web服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest对象处于接收数据状态，XMLHttpRequest对象的readyState属性值为3。
     
            ⑸完成状态。XMLHttpRequest对象接收数据完毕后，进入完成状态，此时XMLHttpRequest对象的readyState属性值为4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用responseText属性或responseXml属性来获取数据。
     
      只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态
     5.发送请求


```

12.js事件代理？

13.js中this是如何工作的

[this指向规则](https://github.com/qiaoshi123/harvester-offer/tree/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/13.this)

14.怎么判断引用数据类型？（为什么能用Object.prototype.toString.call()去判断？）
   
```$javascript
1.instanceof 判断不准确
var a = [];
a instanceof Array  true
a instanceof Object  true 

2.Object.prototype.toString.call([])  '[object Array]'
  Object.prototype.toString.call({})   "[object Object]"
  
  
3.isPrototypeiOf
Array.prototype.isPrototypeOf([])

4.[].constructor == Array.prototype.constructor



扩展：
Array.toString == Function.prototype.toString  true，
根据原型链查找，查到Function.prototype.toString就停了。不会查到Object.prototype

[].toString == Array.prototype.toString  true.
根据原型链查找，查到Array.prototype.toString就停了。不会查到Object.prototype

Array,Function 都在各自的原型上重新定义了toString方法，阻断了查找。





```


15.js变量提升和作用域查找？

[作用域查找](https://github.com/qiaoshi123/harvester-offer/tree/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/11.%E4%BD%9C%E7%94%A8%E5%9F%9F)
```$javascript
console.log(type a) //undefined  变量提升
console.log(type b) //err:b is not defined ,后续代码不执行
console.log(type c) 
var a = function(){return true}; //变量提升
window.b = function(){  //给window创建属性，不存在变量提升
	return true;
}
console.log(a() && b() && c())
function c(){return c}


var o = {
	a:1,
	f(){
		return this.a;
	}
}
console.log(o.f()); //1
var o1 = o;
console.log(o1.f());//1
var o2 = o.f;
console.log(o2()); //undefined  =>this是window，window.a undefined;
o.a=  5;
console.log(o1.f());//5  堆内存 和 栈内存
var o3 = {a:5}; 
console.log(o.f.call(o3)) //5 
```

16.call apply bind 区别？如何实现？

[查看手写call，apply，bind](https://github.com/qiaoshi123/harvester-offer/blob/master/%E5%8E%9F%E7%94%9Fjs%E5%9F%BA%E7%A1%80/5.function/5.function.js)

17.实现跨域的方法？说一下JSOP的原理？

```$javascript
   jsonp
   cors
   服务器反向代理
```
18.正则相关
```javascript
a.正则捕获规则
b.如果是嵌套捕获，得到的顺序是什么样的。
c.正则捕获的引用和反向引用是什么
d.正则的匹配默认是贪婪匹配么

```

19.[].toString()为啥会返回逗号隔开的字符串


20.数据proxy劫持与defineProperty对比。

[阮一峰es6要点总结——Proxy](https://www.jianshu.com/p/81eb68ae5eb1)


# HTML+CSS相关

1.meta标签常用有哪些，列举？viewport属性有哪些分别代表什么（水滴）

2.清除浮动方法？（水滴）

3.口述css盒子模型（水滴）

4.实现左右固定宽度中间自适应布局有哪几种？（水滴）

5.position属性有哪几种，区别？（水滴）

6.左侧固定宽度，右侧自适应？ 多种。

7.用css实现一个三角形，为什么？

8.div垂直水平居中，多种方式（宽高不限）

9.img i iframe video canvas q ol nav form em dl dt dd br hr audio abbr span
strong sub textarea  那些是块？

10.块元素 和行内元素有哪些





# 前端框架相关

1.什么是mvvm？mvvm实现原理？

[手写mvvm框架](https://github.com/qiaoshi123/harvester-offer/tree/master/%E6%A1%86%E6%9E%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/2.mvvm%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF)
```
双向数据绑定
M 数据层
V 视图层
VM View-Modle层，主要用于数据和视图的通讯

利用Object.definedProperty 对data属性的get 和set 进行拦截和监听，并对每个data属性创建一个订阅池。
在编译dom阶段，对dom进行解析，"v-**" "{{}}"，每编译到一处， 完成首次渲染，而且注册一个监听者，添加到data属性的订阅池中。
数据影响视图：当数据改变，则通知该属性对应订阅池中所有的watcher，进行更新。
视图影响数据(v-model): 通过绑定事件，然后改变data属性值，data属性值发生改变，通知所有watcher更新视图。

设计思想：观察者模式，es6 definedProperty拦截。

某一个属性，具备多个watcher，存入到一个dep中。当属性变化，才会去执行dep中的watcher。是由被监听属性（目标属性所触发），所以属于观察者模式。




```

2.vue兄弟组件传递数据？
```$javascript
父传子：通过给子组件绑定属性传值，:data=""。子组件接收通过props设置接收的属性。
子传父：通过事件传值，给子组件绑定事件，@事件名="父组件方法",子组件改变了数据，
通过this.$emit(事件名,data)通知父组件。

兄弟组件传值:中间件
1.
创建一个单独的vm实例。
通过vm.$on('事件名',方法)绑定事件
通过vm.$emit(事件名，data)通知兄弟组件修改数据。
2.合并到同一个父组件下，通过父组件进行传值。
3.vuex

```
3.vuex的使用场景？如何使用？原理？

4.用vue-router实现导航切换 类似tab栏的那种；（一个tab有三个页，下面展示的内容怎么组件实现）

5.vue和react区别 

6.vue 的watch中可以使用箭头函数吗
```$javascript
    不能使用,箭头函数在声明时就确定了this指向，指向的是父级作用域上下文。
    当函数执行时，里面的this并不是vue实例。

```
7.vue自定义组件的双向绑定怎么实现？

8.mvc和mvvm的区别，手画一个原理流程图，类似view model viewmodel的一个流程交互图

9.v-if 和 v-show的区别

10.v-if跟 v-else，如果太多了你可以怎么优化，可以用什么设计模式






# 前端工程化相关
1.webpack基本配置有哪些？

2.vue-cli3脚手架的基本配置？

3.webpack作用？

4.你对脚手架有研究过么?

5.项目打包部署你都是怎么弄的？
```$javascript
jekins部署，具体环境是运维来搭建的。
```


```
1、合并js文件，压缩代码；处理图片资源等静态资源，减少http请求；
2、css预处理，编译less/sass等浏览器不能直接识别的语言；
3、对文件进行hash，可以防止浏览器缓存。
4、一切皆模块，让模块更容易服用，避免重复加载或者加载不必要的模块，并且能够防止全局变量冲突。
```

# 应用场景开发相关

1.简述微信公众号授权过程？

2.客户端与前端的交互的原理 ，怎么交互



#场景算法题

1.将aabbcccda 字符传替换成abcda？（将连续重复的字符去重）
```$javascript
将连续重复的字符去重,这种会有重复项，aabbcccdc=>字符传替换成abcdc
reduce拼接，
function switchStr(str) {
    let arr = str.split('');
    return arr.reduce((prev,next,index,origin)=>{
        if(prev.slice(prev.length-1) == next){
            return prev;
        }else{
            return prev + next;
        }
    },'')
}

function switchStr(str){
    return str.replace(/(.)(/1)+/,function(...args){
        retrun args[1]
    })
}

```

2.js实现字符串trim方法
```$javascript
原生：
var a = '  123  '
a.trim();

js实现：
String.prototype.trim = function(){
    return this.replace(/(^\s+|\s+$)/g,function(){
       return ""
    })
}

```

2.原生js实现字符串split方法？

```javascript


```


3.函数节流？防抖？有何区别？

[防抖,节流](https://juejin.im/post/5c87b54ce51d455f7943dddb)

```javascript
// 函数节流
function throttle(fn,delay) {
    let flag = true;
    return function() {
        if(!flag){
            return;
        }
        flag = false;
        setTimeout(()=>{
            fn.call(this,arguments);
            flag = true;
        },delay)
    }
}

//防抖

function debounce(fn) {
  let timer = null;
  return function() {
    clearTimeout(timer);
    timer = setTimeout(()=>{
        fn.call(this,arguments)
    },1000)
  }
  
  //区分： 节流在一定时间内调用多次，总是执行第一次调用的，执行完成后，才能再次调用。
  //      防抖在一定时间内调用多次，后续的调用会覆盖前面的调用，执行的永远是最后一次调用的。
    
   
}


```

4.[a,b,c],写个方法将数组全排列 ，变成[abc,acb,bac,bca,cab,cba]
```$javascript
思路:每次都取出一个，然后将除去这一个的其他数进行全排列。然后在将取出的那个数拼接到开头
距离：取出a，然后b和c的全排列有两种：bc，cb； 这样就可以算出abc，acb；
    取出b，然后a和c的全排列有两种：ac，ca； 这样就可以算出bac，bca；
    取出c，然后a和b的全排列有两种：ab，ba； 这样就可以算出cab，cba；
    
    递归千万条，出口第一条：出口就是当数组为两项时，就可以自己写出 全排列。

// [a,b,c]=>[abc,acb,bac,bca,cab,cba]
function permute(ary){
    if(ary.length <= 2){
        if(ary.length == 2){
            return [ary.join(''),ary.reverse().join("")]
        }else{
            return [ary[0]]
        }
    }
    let result = [];
    ary.forEach((item,index)=>{
        let all = permute(ary.slice(0,index).concat(ary.slice(index+1)));
        all = all.map(val=>{
            return item+val+'';
        })
        result = result.concat(all);
    })
    return result
}

console.log(permute(["a","b","c"]));

字符串全排列 abc =>[abc,acb,bac,bca,cab,cba]
const anagrams = str => {
    if (str.length <= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];
    return str.split('').reduce((acc, letter, i) =>
        acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)), []);
};
console.log(anagrams('1234'));
数组全排列 [a,b,c]=>[[a,b,c],[a,c,b]...]
    function permute(arr) {
        if(arr.length <= 2){
            if(arr.length == 2){
                return [arr,[arr[1],arr[0]]];
            }else{
                return [arr];
            }
    
        }
        return arr.reduce((prev,next,i)=>{
            let pool= permute(arr.slice(0,i).concat(arr.slice(i+1)));
            pool = pool.map(item=>{
                item.unshift(next);
                return item;
            });
            return prev.concat(pool)
        },[])
    }
    console.log(permute([ 1, 2, 3]));

```
5.数组对象去重

```$javascript

//key 和 value都对比；
//[{a:11,b:12},{c:21,d:22},{a:12,b:11},{c:21,d:22},{a:1,e:{name:'1'}},{a:1,e:{name:'1'}}]
function fn(ary){
    let obj = {};
    for(let i = 0 ;i < ary.length;i++){
        let key = JSON.stringify(ary[i]);
        obj[key] = true;
    }
    return Object.keys(obj).map(item=>{
        return JSON.parse(item)
    })
}


//[{a:11,b:12},{c:21,d:22}],[{a:12,b:11},{c:21,d:22}]
//找出两个数组对象中 key和value都相同的对象。找出{c:21:d:22}

function fn(a1,a2){
    let o1 = {};
    let result = []
    for(let i = 0 ;i<a1.length;i++){
        let key = JSON.stringify(a1[i]);
        o1[key] = true;
    }
    for(let i = 0 ;i<a2.length;i++){
        let key = JSON.stringify(a2[i])
        if(o1[key]){
            result.push(a2[i])
        }
    }
    return result;
}


```

6.你所用到的排序方法

[冒泡、选择、快排、插入排序](https://github.com/qiaoshi123/harvester-offer/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.js)

7.实现一个方法，能够把多重数组变成一个一维数组,flat方法。[1,[1,2],[3,4,5]]转换为[1,1,2,3,4,5]
```javascript
function flat(arr) {
    let result = [];
    for (let i=0;i<arr.length;i++){
        if(Object.prototype.toString.call(arr[i]) == '[object Array]'){
            result = result.concat(flat(arr[i]))
        }else{
            result.push(arr[i])
        }
    } 
    return result;
    
}



```

8.12345数组混排

```$javascript
利用随机数

function switchAry(ary){
    let result = [];
    let len = ary.length;
    for(let i = 0 ;i<len;i++){
       let j =  Math.floor(Math.random()*ary.length); 
       let cur = ary.splice(j,1)[0];
       result.push(cur);
    }
    return result;

}
 // Math.floor(Math.random()*5)  0-4，
 // Math.ceil(Math.random()*5)   1-5
 // Math.round(Math.random()*5)   0-5

```






9.将字符串中重复出现的字符，去重；
```$javascript
   1.转成数组，去重，然后拼接；
    function uqinue(str){
        let ary = str.split("");
        return Array.from(new Set(ary)).join("")    
    }

   2.遍历
    function uqinue(str){
        let result = "";
        for(let i = 0;i<str.length;i++){
            if(result.indexOf(str[i])==-1){
            result = result + str[i]
            }
        }
        return result;
    }
   
   
```
10.abcaaaaaabcabcabcabbbabc 获取abc的重复次数 和索引

```javascript

// 方案1，利用abc进行拆分成数组，数组长度-1为出现次数，；然后计算索引
function get(str,t) {
    let ary = str.split('abc');
    let n  = ary.length - 1;
    let iAry = [];
    ary.reduce((prev,next,i,)=>{
        if(i ==0){
            iAry.push(prev+next.length);
            return prev + next.length;
        }
        if(i == ary.length-1){
            return;
        }
        iAry.push( prev+t.length+next.length);
        return prev+t.length+next.length;

    },0)
    return {n,iAry}
}

var a = 'abcaaaaaabcabcabcabbbabcb'
console.log(get(a, 'abc'));

//方案二：replace方法匹配，参数：[匹配到的整个串，分组，分组...，匹配到整个串的开始索引]
function get(str,t) {
    let reg = new RegExp(t,'g');
    let i = 0;
    let iAry = [];
    str.replace(reg,function (...args) {
        i++;
        iAry.push(args[1])
    })


return {i,iAry}
}

var a = 'abcaaaaaabcabcabcabbbabcb'
console.log(get(a, 'abc'));


```




11.Function instanceof Object 
   Object instanceof Function
```$javascript
  Function instanceof Object 返回true。
  原理：Function 是一个类同时也是一个函数，是Function类的一个实例;
  Function instanceof Function 是true。
  Function.__proto__ == Function.prototype；
  而Function.prototype.__proto__ 是Object.prototype；
  
  
 Object instanceof Function 返回true；
 原理：Object是一个类也是一个函数，所以是Function的一个实例。
 


```

12.用二分查找递归方法，插入一个值并返回索引；有序数组[1,2,3,5,7,8],插入4，返回索引3；
```javascript
   
   //非递归,遍历找到第一个出现大于他的值，然后记住索引，向他前面插入进去。如果没找到，则直接push进去
  function insert(ary,n) {
      let index;
      for(var i = 0 ;i<ary.length;i++){
          if(ary[i]>n){
              index = i;
              break;
          }
      }
      if(i>=ary.length){
          ary.push(n)
          return i;
      }else{
          ary.splice(index,0,n)
          return index;
      }
      
  }
  
  console.log(insert([1, 2, 4], 3));
    function insert(arr,n) {
            var l = [];
            var r = [];
            for(let i = 0 ; i<arr.length;i++){
                if(arr[i]<n){
                    l.push(arr[i])
                }else{
                    r.push(arr[i])
                }
            }
            return {
                index:l.length,
                ary:l.concat([n]).concat(r)
            }
          
        }


//二分插入，递归。
//思路：二分，用左侧最后一项进行比较，如果比插值大，说明应该插入到左侧数组中；
//    递归,继续二分记性比较。
//递归出口：当数组中只有一项时，就可以进行比较，就知道插入到哪了。
       
function insert(ary,num) {
    if(ary.length == 1){
        if(ary[0]>num){
            ary.unshift(num);
        }else{
            ary.push(num);
        }
        return ary;
    }
    let m = Math.floor(ary.length/2);
    let l = ary.slice(0,m);
    let r = ary.slice(m);
    if(l[l.length-1]>num){
        return insert(l,num).concat(r)
    }else{
        return l.concat(insert(r,num))
    }

}
console.log(insert([1, 2, 34,48,68], 34));


   

```

13.计算出数组的最大差值 [12,5,11,7,33,9](程序设计)
```javascript
   function adjective(arr) {
    let max = Math.max(...arr);
    let min = Math.min(...arr);
    return max - min 
    
   }
   
   
   //假设法
   function adjective(arr) {
    let min = arr[0];
    let max = arr[0];
    for(let i = 1; i<arr.length;i++){
        if(arr[i]<=min){
            min = arr[i];
        }
        if(arr[i]>=max){
            max = arr[i]
        }
    }
     return max - min ;
   }
   

```


14.请写出检查元素是否在屏幕可视区域的关键代码；
```$javascript
图片懒加载的原理：
方案一：1.获取图片 距离 滑动内容盒子 顶部的offsetTop
      （需要给滑动内容盒子增加position:relative属性，使他成为父级参照物）
        offsetParent:父级参照物
        第一个具有position属性且非static的父级，没有的话，最终是body
        一般情况下页面中所有元素的父级参照物都是body;
        document.body.offsetParent =>null//body 的父级参照物是null）
       2.获取滚动窗口的scrollTop值。
       3.获取滚动窗口的clientHeight值。
       
       监听滚动事件：当clientHeight+scrollTop >=offsetTop时，则进入了窗口。
       
       
方案二:dom.getBoundingClientRect()是获取某个元素相对于视窗的位置集合;
      {top,left,right,bottom}，四个值都是距离左边或者顶部的距离。
      1.通过getBoundingclientRect().top,获取当前原理距离视窗顶部的距离
      2.获取可视窗的高度document.body.clientHeight。
      3.当元素距离视窗顶部距离 < 视窗高度，则出现在视窗内
     
```

15.将片段1 用正则表达式替换成片段2

```$javascript

片段1 <h1  class="h4"><span class="label">boss直聘</span><h1>

片段2 <h1  class=\"h4\"><span class=\"label\">boss直聘</span><h1>
    function replaceStr(str) {
        let result = str.replace(/"/g,function(...args) {
          return "/"+args[0]
        })  
    
        return result;
    
    }

```


# DOM相关

1.如何判断一个dom是否在视窗中


```$javascript
图片懒加载的原理：
方案一：1.获取图片 距离 滑动内容盒子 顶部的offsetTop
      （需要给滑动内容盒子增加position:relative属性，使他成为父级参照物）
        offsetParent:父级参照物
        第一个具有position属性且非static的父级，没有的话，最终是body
        一般情况下页面中所有元素的父级参照物都是body;
        document.body.offsetParent =>null//body 的父级参照物是null）
       2.获取滚动窗口的scrollTop值。
       3.获取滚动窗口的clientHeight值。
       
       监听滚动事件：当clientHeight+scrollTop >=offsetTop时，则进入了窗口。
       
       
方案二:dom.getBoundingClientRect()是获取某个元素相对于视窗的位置集合;
      {top,left,right,bottom}，四个值都是距离左边或者顶部的距离。
      1.通过getBoundingclientRect().top,获取当前原理距离视窗顶部的距离
      2.获取可视窗的高度document.body.clientHeight。
      3.当元素距离视窗顶部距离 < 视窗高度，则出现在视窗内
     
```


2.dom事件中 DOMContentLoaded和window.onload的触发实际是什么 ？图片加载完成后是一个什么情况？

```javascript

//DOMContentLoaded 事件是DOM元素全部加载完成之后就会触发，图片等其他信息加载之前调用
// 在Dom节点创建完成后执行，如果有多个定义，则触发后会依次执行。
// jquery:
$(function() {
    //do something
})
$(document).ready(function() {
  //do something
})
$().ready(function() {
  //do something 
  //jquery默认参数是document $()
})
// 以上三种方式都是jq提供的dom加载完成事件，都是基于DOMContentLoaded dom2级事件的。
document.addEventListener('DOMContentLoaded', function() {
     // 此方法为原生js DOM加载完成执行的事件
})

//windown.onload
// 加载完所有页面内容才会触发，包括所有内容,包括图片，flash等所有文件.如果页面的这些内容很多会让用户等待很 长时间.
//只能定义一个，如果有多个定义则只执行最后一个


// 举例
// 比如：页面中只有一个img标签，当img节点创建完后就会执行$(function(){})中的代码，
// 当img的src指定的图片完全加载完后才会触发window.onload事件。


```





# 性能优化相关？

1.列举你能想到的前端性能问题和安全问题


2.项目优化方法

3.错误检测上报日志怎么实现的。

4.fis3 和 webpack的区别是什么

5.请列举最重要的前端优化点(按重要性)






# 扩展知识？能聊就行～

1.简述CI/CD？

2.多态和重载？

3.了解服务端的反向代理吗？

4.订餐功能 如何实现的？

# 设计模式
1.观察者模式 和 订阅发布模式的区别

![image](https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)
```javascript
// 观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。
// 观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，会造成代码的冗余。而发布订阅模式则统一由调度中心处理，
// 消除了发布者和订阅者之间的依赖。




```



  



# 程序执行题

1.代码执行结果
```javascript
var data = {
    name:'boss',
    age:3
}
console.log(data.age);//3
observe(data);
console.log(data.age);//4

data.age = 5; //val = 6
console.log(data.age)//7

function observe(data) {
    Object.keys(data).forEach(function (key) {
        defineReactive(data,key,data[key])
    })
}
function defineReactive(data,key,val) {

    Object.defineProperty(data,key,{
        enumerable:true,
        configurable:true,
        get(){
            return val +1;
        },
        set(newVal){
            val = newVal+1;
        }
    })

}


```
2.代码执行结果
```javascript
const arr = [1,2,3,4,5,6];
const  res = arr.filter(value  =>value%2).map(item=>item*item).reduce((a,b)=>a+b);
console.log(res);//35
console.log(arr.pop());//6
console.log(arr);//[1,2,3,4,5]


```
3.程序输出结果
```javascript
const arr = [1,2,3,4,5,6]
for(var i = 0;i<arr.length;i++){
    setTimeout(_=>{
        console.log(arr[i])
    },0)
}
//输出6个undefined


```






